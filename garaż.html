<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Zabudo.pl - Wszystko zaczyna się od marzenia</title>

  <!-- JSON-LD -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "LocalBusiness",
    "name": "Zabudo.pl",
    "description": "Budynki gospodarcze na wymiar – hale stalowe, wiaty, garaże blaszane, konstrukcje rolnicze. Montaż Śląsk i Małopolska.",
    "url": "https://www.zabudo.pl",
    "telephone": "+48503702467",
    "email": "adam@zabudo.pl",
    "address": {
      "@type": "PostalAddress",
      "streetAddress": "ul. Przykładowa 1",
      "addressLocality": "Siewierz",
      "addressRegion": "Śląskie",
      "postalCode": "42-470",
      "addressCountry": "PL"
    },
    "areaServed": ["Śląsk", "Małopolska", "Siewierz", "Zawiercie", "Myszków", "Łazy", "Poręba", "Żarki", "Koziegłowy", "Ożarowice", "Wojkowice Kościelne"],
    "openingHours": "Mo-Fr 08:00-17:00",
    "sameAs": []
  }
  </script>

  <!-- Meta -->
  <meta name="description" content="Zabudo.PL – Budujemy trwałe, funkcjonalne budynki gospodarcze na wymiar na Śląsku i w Małopolsce. Szybka realizacja, montaż i atrakcyjne ceny.">
  <meta name="keywords" content="budynki gospodarcze, konstrukcje stalowe, garaże blaszane, Śląsk, Małopolska, Siewierz, budowa, montaż, solidne budynki, na wymiar, blaszaki, Zabudo.pl">
  <meta name="author" content="Zabudo.pl">
  <meta name="robots" content="index, follow">
  <meta property="og:title" content="Wszystko zaczyna się od marzenia | Zabudo.pl">
  <meta property="og:description" content="Budowa i montaż budynków gospodarczych dopasowanych do Twoich potrzeb. Działamy na Śląsku i w Małopolsce.">
  <meta property="og:image" content="URL_DO_Twojej_Głównej_Grafiki.jpg">
  <meta property="og:url" content="https://www.zabudo.pl">

  <!-- Fonts & CSS -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <link rel="stylesheet" href="style.css" />

  <!-- Favicons -->
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="manifest" href="site.webmanifest">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
</head>


<script>
// === ZBIERANIE KONFIGURACJI + PRZEJŚCIE DO PODSUMOWANIA ===

(function() {
  // Pomocnicze: ładnie wytnij tekst tytułu grupy (bez checkboxa)
  function getGroupTitle(poleWyboru) {
    const t = poleWyboru.querySelector('.pole-wyboru-tytuł');
    if (!t) return '';
    // klon, żeby usunąć input i wziąć sam tekst
    const clone = t.cloneNode(true);
    const inp = clone.querySelector('input');
    if (inp) inp.remove();
    return clone.textContent.trim().replace(/\s+/g, ' ');
  }

  // Zwraca listę wszystkich aktywnych (zaznaczonych) opcji z panelu usług,
  // w formacie uniwersalnym (nazwa grupy, wybrana etykieta, data-* itp.)
  function collectServicesConfig(root) {
    const out = [];
    root.querySelectorAll('.usługi-menu-wyboru .pole-wyboru').forEach(pole => {
      const main = pole.querySelector('.main-check');
      if (!main || !main.checked) return;

      const groupTitle = getGroupTitle(pole) || 'Opcja';
      const checked = pole.querySelector('.opcje input[type="checkbox"]:checked');

      const selected = checked ? {
        label: (checked.closest('label')?.innerText || '').replace(/\(\+\d[\d\s.,]* zł\)\s*$/,'').trim(),
        type: (checked.dataset.type || 'fixed'),
        price: parseFloat(checked.dataset.price || '0') || 0
      } : null;

      out.push({
        group: groupTitle,
        selected // może być null, jeśli ktoś rozwinął grupę i nic nie zaznaczył
      });
    });
    return out;
  }

  // Znajdź aktywny kontener i odczytaj suwakowe wartości
  function collectActiveBuildConfig() {
    const active = document.querySelector('.build-container.active');
    if (!active) return null;

    const id = active.id.replace('container','');
    const width = parseFloat(active.querySelector(`#widthRange${id}`)?.value || '0');
    const length = parseFloat(active.querySelector(`#lengthRange${id}`)?.value || '0');
    const hEave = parseFloat(active.querySelector(`#heightRange${id}`)?.value || '0');      // okap
    const hPeak = parseFloat(active.querySelector(`#heightPeakRange${id}`)?.value || '0');  // kalenica

    // Nazwa „typu” z przycisku burger-menu (ładny label do podsumowania)
    let buildType = '';
    document.querySelectorAll('#burgerMenu button[data-target]').forEach(btn => {
      if (btn.classList.contains('active')) buildType = btn.textContent.trim();
    });

    // Cena z widoku (to, co użytkownik widzi)
    const priceEl = active.querySelector(`#priceEstimate${id}`);
    const shownPrice = priceEl ? priceEl.textContent.trim() : '';

    return {
      containerId: id,
      buildType,            // np. "garaż jednostanowiskowy"
      width,
      length,
      height_eave: hEave,   // wysokość w najniższym pkt
      height_peak: hPeak,   // wysokość w najwyższym pkt
      shownPrice            // np. "45 123 zł"
    };
  }

  // Główna funkcja: podpinamy się pod wszystkie linki "Zamów teraz!"
  function wireOrderButtons() {
    document.querySelectorAll('.build-container a.btn[href]').forEach(a => {
      // tylko linki w sekcji cenowej (żeby nie łapać innych)
      a.addEventListener('click', function(e) {
        try {
          const buildCfg = collectActiveBuildConfig();
          if (!buildCfg) return; // pozwól iść normalnie

          const services = collectServicesConfig(document);

          const payload = {
            version: 1,
            ts: new Date().toISOString(),
            build: buildCfg,
            services
          };

            // Zapisz do sessionStorage i przejdź dalej
          sessionStorage.setItem('orderConfig', JSON.stringify(payload));
          // przechodzimy normalnie na href (nie blokujemy nawigacji)
        } catch (err) {
          // w razie czego nie blokuj zamówienia
          console.error('Błąd zapisu konfiguracji:', err);
        }
        // nie wywołujemy preventDefault – chcemy iść na href
      });
    });
  }

  // start
  document.addEventListener('DOMContentLoaded', wireOrderButtons);
})();
</script>


<script>
// Ustawia wartość suwaka + emituje "input" (żeby wszystko zareagowało "live")
function setRangeValue(rangeEl, value) {
  if (!rangeEl) return;
  rangeEl.value = value;
  rangeEl.dispatchEvent(new Event('input', { bubbles: true })); // <<< najważniejsze
}
</script>




<script defer src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

<script>
(() => {
  // ————————————————————————————————
  // KONFIG
  // ————————————————————————————————
  const SCALE = 2; // raster 2x (retina)

  // DejaVu Sans z Latin-Extended (ma polskie znaki)
  const FONT_URL = 'https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf';
  const FONT_NAME = 'DejaVu';      // logiczna nazwa w jsPDF
  const FONT_FILE = 'DejaVuSans.ttf';

  // ————————————————————————————————
  // UTILS (Twoje podstawowe)
  // ————————————————————————————————
  function getActiveContainer(){
    return document.querySelector('.build-container.active') || document.getElementById('container1');
  }
  function getActiveId(){
    const c = getActiveContainer();
    return c ? c.id.replace('container','') : '1';
  }
  function getTypeNameById(id){
    return id === '2' ? 'garaż dwustanowiskowy' : 'garaż jednostanowiskowy';
  }

function buildSummaryLines(){
  const active = getActiveContainer();
  if (!active) return [];

  const id = getActiveId();
  const type = getTypeNameById(id);
  const w = parseFloat(active.querySelector(`#widthRange${id}`)?.value || '0');
  const l = parseFloat(active.querySelector(`#lengthRange${id}`)?.value || '0');
  const e = parseFloat(active.querySelector(`#heightRange${id}`)?.value || '0');
  const p = parseFloat(active.querySelector(`#heightPeakRange${id}`)?.value || '0');
  const priceTxt = active.querySelector(`#priceEstimate${id}`)?.textContent?.trim() || '';

  const lines = [];
  lines.push('Projekt budynku – podsumowanie konfiguracji');
  lines.push('');
  lines.push(`Typ: ${type}`);
  if (Number.isFinite(w) && Number.isFinite(l)) lines.push(`Wymiary: ${w.toFixed(1)} × ${l.toFixed(1)} m`);
  if (Number.isFinite(e)) lines.push(`Okap: ${e.toFixed(1)} m`);
  if (Number.isFinite(p)) lines.push(`Kalenica: ${p.toFixed(1)} m`);
  if (priceTxt && !/\(.*\)|Dostosuj/i.test(priceTxt)) {
    lines.push('');
    lines.push(`Szacunkowa cena (łącznie): ${priceTxt}`);
  }

  // === DODATKOWA KONFIGURACJA ===
  // helper: tytuł grupy bez inputa
  const getGroupTitleFromPole = (pole) => {
    const t = pole.querySelector('.pole-wyboru-tytuł');
    if (!t) return 'Opcja';
    const clone = t.cloneNode(true);
    const inp = clone.querySelector('input');
    if (inp) inp.remove();
    return clone.textContent.trim().replace(/\s+/g, ' ') || 'Opcja';
  };

  const extras = [];
  // BIERZEMY KAŻDĄ ZAZNACZONĄ POD-OPCJĘ, nie patrzymy na .main-check
  document.querySelectorAll('.usługi-menu-wyboru .pole-wyboru .opcje input[type="checkbox"]:checked')
    .forEach(checked => {
      const pole = checked.closest('.pole-wyboru');
      const groupTitle = getGroupTitleFromPole(pole);

      let label = '';
      const lblEl = checked.closest('label');
      if (lblEl) {
        const clone = lblEl.cloneNode(true);
        clone.querySelectorAll('input, .price-tag').forEach(n => n.remove());
        label = clone.textContent.trim()
                 .replace(/\(\+\s*[\d\s.,]+ zł\)\s*$/i, ''); // usuń „(+ … zł)”
      }
      if (!label || label.toLowerCase() === 'on') {
        label = (checked.value && checked.value.toLowerCase() !== 'on') ? checked.value : '';
      }
      if (label) extras.push(`${groupTitle}: ${label}`);
    });

  if (extras.length) {
    lines.push('');
    lines.push('Dodatkowa konfiguracja:');
    extras.forEach(x => lines.push(`- ${x}`));
  }

  return lines;
}

  async function loadImageSmart(url){
    if (!url) return null;
    if (url.startsWith('data:')) {
      return await new Promise(res => {
        const img = new Image();
        img.onload = () => res(img);
        img.onerror = () => res(null);
        img.src = url;
      });
    }
    try{
      const resp = await fetch(url, { mode: 'cors' });
      const blob = await resp.blob();
      const dataUrl = await new Promise(r => {
        const fr = new FileReader();
        fr.onload = () => r(fr.result);
        fr.readAsDataURL(blob);
      });
      return await loadImageSmart(dataUrl);
    }catch(_){
      return await new Promise(res => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => res(img);
        img.onerror = () => res(null);
        img.src = url;
      });
    }
  }

  function extractBgUrl(cs){
    const bi = cs.backgroundImage || '';
    const m = bi.match(/url\((['"]?)(.+?)\1\)/i);
    return m ? m[2] : '';
  }

  function computeBgDrawBox(imgW, imgH, boxW, boxH, sizeStr){
    let dw = imgW, dh = imgH;
    const toPx = (v, total) => {
      if (typeof v !== 'string') return v;
      if (v.endsWith('%')) return parseFloat(v)/100 * total;
      return parseFloat(v);
    };
    const parts = (sizeStr || '').trim().toLowerCase().split(/\s+/);
    if (parts.length === 1) {
      const s = parts[0];
      if (!s || s === 'auto') {
        // natural
      } else if (s === 'cover') {
        const arI = imgW / imgH, arB = boxW / boxH;
        if (arI > arB) { dh = boxH; dw = dh * arI; }
        else           { dw = boxW; dh = dw / arI; }
      } else if (s === 'contain') {
        const arI = imgW / imgH, arB = boxW / boxH;
        if (arI > arB) { dw = boxW; dh = dw / arI; }
        else           { dh = boxH; dw = dh * arI; }
      } else if (s.endsWith('px') || s.endsWith('%') || !isNaN(parseFloat(s))) {
        dw = toPx(s, boxW);
        const ar = imgW / imgH;
        dh = dw / ar;
      }
    } else if (parts.length >= 2) {
      const wStr = parts[0], hStr = parts[1];
      const w = (wStr === 'auto') ? null : toPx(wStr, boxW);
      const h = (hStr === 'auto') ? null : toPx(hStr, boxH);
      if (w && h) { dw = w; dh = h; }
      else if (w) { dw = w; dh = w * (imgH / imgW); }
      else if (h) { dh = h; dw = h * (imgW / imgH); }
    }
    const dx = (boxW - dw) / 2;
    const dy = (boxH - dh) / 2;
    return { dx, dy, dw, dh };
  }

  async function renderWrapperToCanvas(wrapper){
    if (!wrapper) return null;
    const rect = wrapper.getBoundingClientRect();
    const w = Math.max(1, Math.round(rect.width));
    const h = Math.max(1, Math.round(rect.height));

    const cv = document.createElement('canvas');
    cv.width = w * SCALE;
    cv.height = h * SCALE;
    const ctx = cv.getContext('2d');
    ctx.scale(SCALE, SCALE);

    const cs = getComputedStyle(wrapper);
    const bgColor = cs.backgroundColor && cs.backgroundColor !== 'transparent'
      ? cs.backgroundColor : '#ffffff';
    ctx.fillStyle = bgColor;
    ctx.fillRect(0,0,w,h);

    const bgUrl = extractBgUrl(cs);
    if (bgUrl) {
      const img = await loadImageSmart(bgUrl);
      if (img && img.naturalWidth && img.naturalHeight) {
        const box = computeBgDrawBox(
          img.naturalWidth, img.naturalHeight,
          w, h,
          cs.backgroundSize || 'cover'
        );
        ctx.drawImage(img, box.dx, box.dy, box.dw, box.dh);
      }
    }

    const toLocal = (r) => ({
      x: r.left - rect.left,
      y: r.top  - rect.top,
      w: r.width,
      h: r.height
    });

    // IMG
    const imgEls = wrapper.querySelectorAll('img');
    for (const el of imgEls){
      const r = toLocal(el.getBoundingClientRect());
      if (r.w <= 0 || r.h <= 0) continue;
      const src = el.currentSrc || el.src;
      const img = await loadImageSmart(src);
      if (img) ctx.drawImage(img, r.x, r.y, r.w, r.h);
    }

    // SVG
    const svgs = wrapper.querySelectorAll('svg');
    for (const svg of svgs){
      const r = toLocal(svg.getBoundingClientRect());
      if (r.w <= 0 || r.h <= 0) continue;

      const clone = svg.cloneNode(true);
      clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
      clone.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
      const imgs = clone.querySelectorAll('image');
      for (const im of imgs){
        const href = im.getAttribute('href') || im.getAttributeNS('http://www.w3.org/1999/xlink','href');
        if (!href) continue;
        const img = await loadImageSmart(href);
        if (img){
          try {
            const c2 = document.createElement('canvas');
            c2.width = img.naturalWidth; c2.height = img.naturalHeight;
            const ct2 = c2.getContext('2d');
            ct2.drawImage(img,0,0);
            const data = c2.toDataURL('image/png');
            im.setAttribute('href', data);
            im.removeAttribute('crossorigin');
          } catch(_){}
        }
      }

      const s = new XMLSerializer().serializeToString(clone);
      const blob = new Blob([s], { type:'image/svg+xml;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      await new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          ctx.drawImage(img, r.x, r.y, r.w, r.h);
          URL.revokeObjectURL(url);
          resolve();
        };
        img.onerror = () => { URL.revokeObjectURL(url); resolve(); };
        img.src = url;
      });
    }

    return cv;
  }

  async function renderPlanToCanvas(){
    const active = getActiveContainer();
    try { if (typeof updateBuildingMap === 'function') updateBuildingMap(); } catch(_){}
    return await renderWrapperToCanvas(active?.querySelector('.dimensions-map'));
  }
  async function renderElevationToCanvas(){
    const active = getActiveContainer();
    try { if (typeof updateBuildingElevation === 'function') updateBuildingElevation(); } catch(_){}
    return await renderWrapperToCanvas(active?.querySelector('.dimensions-map-height'));
  }

  // ————————————————————————————————
  // FONT: osadzenie TTF do jsPDF (PL znaki)
  // ————————————————————————————————
async function ensureEmbeddedFont(jsPDF, pdf){
  // jeśli już mamy zcache’owaną bazę64,
  if (window.__dejavu_ready__ && window.__dejavu_b64){
    pdf.addFileToVFS(FONT_FILE, window.__dejavu_b64);
    pdf.addFont(FONT_FILE, FONT_NAME, 'normal');
    return;
  }

  // pobierz i zakoduj TTF -> base64 (raz, cache w window)
  const resp = await fetch(FONT_URL);
  const buf = await resp.arrayBuffer();
  let binary = '';
  const bytes = new Uint8Array(buf);
  for (let i=0; i<bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
  const b64 = btoa(binary);

  // cache
  window.__dejavu_b64 = b64;
  window.__dejavu_ready__ = true;

  // rejestracja na aktualnym egzemplarzu PDF
  pdf.addFileToVFS(FONT_FILE, b64);
  pdf.addFont(FONT_FILE, FONT_NAME, 'normal');
}

  // ————————————————————————————————
  // PDF builder (Blob URL preview + font z PL znakami)
  // ————————————————————————————————

  async function buildPdfDoc(){
  const { jsPDF } = window.jspdf;

  // 1) Pobierz canvasy (może być przed lub po utworzeniu pdf — bez znaczenia)
  const [planCv, elevCv] = await Promise.all([
    renderPlanToCanvas(),
    renderElevationToCanvas()
  ]);

  // 2) Utwórz JEDEN egzemplarz PDF i osadź na nim font
  const pdf = new jsPDF({ unit:'mm', format:'a4' });
  await ensureEmbeddedFont(jsPDF, pdf);

  // 3) Dalej normalnie rysuj
  const margin = 12;
  const pageW = pdf.internal.pageSize.getWidth();
  const pageH = pdf.internal.pageSize.getHeight();
  const maxW  = pageW - margin*2;
  let y = margin;

  // — podsumowanie tekstem z polskimi ogonkami
  pdf.setFont(FONT_NAME, 'normal');
  pdf.setFontSize(12);
  const lines = buildSummaryLines();
  const wrapped = pdf.splitTextToSize(lines.join('\n'), maxW);
  pdf.text(wrapped, margin, y, { baseline: 'top' });
  y += (wrapped.length * 5) + 8;

  function addCanvas(cv){
    if (!cv) return;
    const ratio = cv.width / cv.height;
    let imgWmm = maxW;
    let imgHmm = imgWmm / ratio;
    if (y + imgHmm > pageH - margin){
      pdf.addPage();
      pdf.setFont(FONT_NAME, 'normal');
      y = margin;
    }
    const maxHmm = pageH - margin - y;
    if (imgHmm > maxHmm){ imgHmm = maxHmm; imgWmm = imgHmm * ratio; }
    pdf.addImage(cv.toDataURL('image/png'), 'PNG', margin, y, imgWmm, imgHmm, undefined, 'FAST');
    y += imgHmm + 8;
  }

  addCanvas(planCv);
  addCanvas(elevCv);

  pdf.setFontSize(9);
  pdf.text('Wygenerowano na Zabudo.pl', margin, pageH - margin);

  const blobUrl = pdf.output('bloburl');

  const preview = document.getElementById('pdfPreview');
  if (preview){
    preview.innerHTML = '';
    const ifr = document.createElement('iframe');
    ifr.style.width = '100%';
    ifr.style.height = '320px';
    ifr.style.border = '0';
    ifr.src = blobUrl;
    preview.appendChild(ifr);

    ifr.addEventListener('error', () => {
      preview.innerHTML = '';
      const obj = document.createElement('object');
      obj.type = 'application/pdf';
      obj.data = blobUrl;
      obj.style.width = '100%';
      obj.style.height = '320px';
      preview.appendChild(obj);
    });
  }

  return { pdf, blobUrl, filename: makeFilename() };
}


  function makeFilename(){
    const ts  = new Date().toISOString().slice(0,10);
    const id  = getActiveId();
    const typ = getTypeNameById(id);
    return `projekt-${typ.replace(/\s+/g,'_')}-${ts}.pdf`;
  }

  async function handleDownloadPdf(){
    try{
      const res = await buildPdfDoc();
      res.pdf.save(res.filename || 'projekt.pdf');
    }catch(e){
      console.error(e);
      const preview = document.getElementById('pdfPreview');
      if (preview) preview.innerHTML =
        `<div class="text-danger">Nie udało się wygenerować/pobrać PDF. Szczegóły w konsoli – ${e?.message || e}</div>`;
    }
  }

  // ————————————————————————————————
  // INIT
  // ————————————————————————————————
  document.addEventListener('DOMContentLoaded', () => {
    const dl = document.getElementById('downloadPdfBtn');
    if (dl) dl.addEventListener('click', handleDownloadPdf);

    const modalEl = document.getElementById('saveProjectModal');
    if (modalEl){
      modalEl.addEventListener('shown.bs.modal', async () => {
        try { await buildPdfDoc(); }
        catch (e) {
          console.error('PDF init error:', e);
          const preview = document.getElementById('pdfPreview');
          if (preview) preview.innerHTML =
            `<div class="text-danger">Nie udało się wygenerować podglądu PDF. ${e?.message || e}</div>`;
        }
      });
    }
  });
})();
</script>







<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg fixed-top">
    <div class="container">
     <a href="index.html"> <img id="ikonazab" src="logo_zabudo_white.webp" alt="Logo białe"  loading="lazy" /></a>
      <a href="index.html"> <img id="ikonablack" src="logo_zabudo_black.webp" alt="Logo czarne"  loading="lazy" /></a>

      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <div class="line"></div>
        <div class="line"></div>
        <div class="line"></div>

      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
 

          <li class="nav-item"><a class="nav-link" href="#top">Kreator budynku</a></li>
          <li class="nav-item"><a class="nav-link" href="#contact">Kontakt</a></li>
           <li class="nav-item"><a class="nav-link" href="#footer">Wizytówka</a></li>
  
        </ul>
      </div>
    </div>
  </nav>

<div class="sklep-wrapper" id="top">

  <div class="kreator-welcome" id="kreator-budynku">
<h1>Zaprojektuj garaż swoich marzeń!</h1>

  </div>




    <div id="burgerMenu" class="burger-menu">
      <button data-target="container1" class="btn btn-sm btn-outline-dark active">garaż jednostanowiskowy</button>
      <button data-target="container2" class="btn btn-sm btn-outline-dark">garaż dwustanowiskowy</button>
    </div>

    <button class="konfiguracja">szczegółowa konfiguracja</button>

    <div class="usługi-menu-wyboru" >




      <div class="pole-wyboru">
        
<div class="pole-wyboru-tytuł">
      <input type="checkbox" class="main-check" /> Ocieplenie
</div>

  <div class="opcje">
    
     <label class="opcja-1">
      <input type="checkbox" data-type="sqm" data-price="74"/> 50 mm
    </label>

        <label class="opcja-2">
      <input type="checkbox" data-type="sqm" data-price="134"/> 100 mm
    </label>

    <label class="opcja-3">
      <input type="checkbox" data-type="sqm" data-price="157"/> 150 mm
    </label>

  </div>
      </div>



       <div class="pole-wyboru">
        
<div class="pole-wyboru-tytuł">
      <input type="checkbox" class="main-check" /> Fundament
</div>

  <div class="opcje">
    
     <label class="opcja-1">
      <input type="checkbox" data-type="sqm" data-price="97"/> Płyty chodnikowe na podsypce piaskowej
    </label>

        <label class="opcja-2">
      <input type="checkbox" data-type="sqm" data-price="138"/> Płyty chodnikowe z dodatkowym utwardzeniem podłoża
    </label>

    <label class="opcja-3">
      <input type="checkbox" data-type="sqm" data-price="156"/> Płyta betonowa
    </label>

        <label class="opcja-4">
      <input type="checkbox" data-type="sqm" data-price="185"/> Płyta betonowa z dodatkowym utwardzeniem podłoża
    </label>

  </div>
      </div>



           <div class="pole-wyboru">
        
<div class="pole-wyboru-tytuł">
      <input type="checkbox" class="main-check" /> Okna
</div>

  <div class="opcje">
    
     <label class="opcja-1">
      <input type="checkbox" data-type="fixed" data-price="2784"/> jedno
    </label>

        <label class="opcja-2">
      <input type="checkbox" data-type="fixed" data-price="4458"/> dwa
    </label>

    <label class="opcja-3">
      <input type="checkbox" data-type="fixed" data-price="6365"/> trzy
    </label>

  </div>
      </div>






    </div>




    

    <div class="build-type-wrapper text-center mb-3">

      <!-- Kontener 1: Garaż 1 -->

      <div id="container1" class="build-container active">
        <h2 class="section-title">Garaż jednostanowiskowy</h2>


        <div class="range-section">
   
          <div class="mb-3">
            <label for="widthRange1">Szerokość (3–10 m):</label>
            <input type="range"  id="widthRange1" min="3" max="10" step="0.1" value="6" />
            <span id="widthValue1">6</span> m
          </div>
          <div class="mb-3">
            <label for="lengthRange1">Długość (3–10 m):</label>
            <input type="range" id="lengthRange1" min="3" max="10" step="0.1" value="6" />
            <span id="lengthValue1">6</span> m
          </div>



          <div class="dimensions-map">
            <div id="buildingMap" class="building-map map1"></div>

          </div>



        <div class="range-selection-height">
         
<div class="mb-3">
  <label for="heightRange1">Okap (2–5.8 m):</label>
  <input type="range" id="heightRange1" min="2" max="5.8" step="0.1" value="3.5" />
  <span id="heightValue1">3.5</span> m
</div>

<div class="mb-3">
  <label for="heightPeakRange1">Kalenica (2–6 m):</label>
  <input type="range" id="heightPeakRange1" min="2" max="6" step="0.1" value="4.2" />
  <span id="heightPeakValue1">4.2</span> m
</div>


          <div class="dimensions-map-height">
            <div id="buildingMapheight" class="building-map-height mapheight" ></div>

          </div>




          <div class="price-box">
            Szacowana cena: <strong id="priceEstimate1">(Dostosuj wymiary)</strong> 

            <div class="price-box-buttons">

                   <button type="button"
        class="btn btn-secondary mt-3 js-save-project"
        data-bs-toggle="modal"
        data-bs-target="#saveProjectModal">
  Zapisz projekt
</button>

            <a href="podsumowanie.html" class="btn btn-secondary mt-3">Zamów teraz!</a>
          </div>
          
          </div>
        </div>
      </div>
      </div>


      <!-- Kontener 2: Garaż 2 stanowiska -->

 <div id="container2" class="build-container">
  <h2 class="section-title">Garaż dwustanowiskowy</h2>

  <div class="range-section">
    <p>Wybierz przybliżone wymiary budynku i poznaj szacunkową cenę:</p>

    <div class="mb-3">
      <label for="widthRange2">Szerokość (5–10 m):</label>
      <input type="range" id="widthRange2" min="5" max="10" step="0.1" value="7" />
      <span id="widthValue2">7</span> m
    </div>

    <div class="mb-3">
      <label for="lengthRange2">Długość (3–10 m):</label>
      <input type="range" id="lengthRange2" min="3" max="10" step="0.1" value="6" />
      <span id="lengthValue2">6</span> m
    </div>

    <div class="dimensions-map">
      <div class="building-map map2"></div>
    </div>

    <div class="range-selection-height">
      <div class="mb-3">
        <label for="heightRange2">Wysokość w najniższym punkcie (2–5.8 m):</label>
        <input type="range" id="heightRange2" min="2" max="5.8" step="0.1" value="3.5" />
        <span id="heightValue2">3.5</span> m
      </div>

      <div class="mb-3">
        <label for="heightPeakRange2">Wysokość w najwyższym punkcie (2–6 m):</label>
        <input type="range" id="heightPeakRange2" min="2" max="6" step="0.1" value="4.2" />
        <span id="heightPeakValue2">4.2</span> m
      </div>

      <div class="dimensions-map-height">
        <div class="building-map-height mapheight"></div>
      </div>

      <div class="price-box">
        Szacowana cena: <strong id="priceEstimate2">(Dostosuj wymiary)</strong>
            <div class="price-box-buttons">

              <button type="button"
        class="btn btn-secondary mt-3 js-save-project"
        data-bs-toggle="modal"
        data-bs-target="#saveProjectModal">
  Zapisz projekt
</button>

            <a href="podsumowanie.html" class="btn btn-secondary mt-3">Zamów teraz!</a>
          </div>
      </div>
    </div>
  </div>
</div>

    </div>  


      <!-- Obsługa pól wyboru -->

<script>

  const btn = document.querySelector('.konfiguracja');
  const menu = document.querySelector('.usługi-menu-wyboru')

  btn.addEventListener('click', () => {
    btn.classList.toggle('aktywny');
    menu.classList.toggle('aktywny');
  })
  
</script>


<script>
  document.querySelectorAll(".pole-wyboru").forEach(pole => {
    const mainCheckbox = pole.querySelector(".main-check");
    const opcje = pole.querySelector(".opcje");

    mainCheckbox.addEventListener("change", () => {
      if (mainCheckbox.checked) {
        opcje.classList.add("rozwinięty");
      } else {
        opcje.classList.remove("rozwinięty");
      }
    });
  });
</script>
    


<script>
document.addEventListener("DOMContentLoaded", () => {
  // --- pomocnicze: m² w danym kontenerze (z suwaków) ---
  function getAreaFromContainer(container) {
    const w = parseFloat(container.querySelector('input[id^="widthRange"]')?.value || '0');
    const l = parseFloat(container.querySelector('input[id^="lengthRange"]')?.value || '0');
    return (isNaN(w) || isNaN(l)) ? 0 : w * l;
  }

  // --- UI: obsługa pól wyboru (jak u Ciebie) ---
  document.querySelectorAll(".pole-wyboru").forEach(pole => {
    const mainCheckbox = pole.querySelector(".main-check");
    const opcje = pole.querySelector(".opcje");
    const subOptions = opcje.querySelectorAll("input[type=checkbox]");

    mainCheckbox.addEventListener("change", () => {
      if (mainCheckbox.checked) {
        opcje.classList.add("rozwinięty");
      } else {
        opcje.classList.remove("rozwinięty");
        // Odznacz wszystkie opcje wewnętrzne
        subOptions.forEach(c => (c.checked = false));
        updateCalculatorForAll();
      }
    });

    subOptions.forEach(opt => {
      opt.addEventListener("change", () => {
        if (opt.checked) {
          // tylko jedna opcja w grupie
          subOptions.forEach(o => { if (o !== opt) o.checked = false; });
        }
        updateCalculatorForAll();
      });
    });
  });

  // --- liczenie dopłat (uwzględnia sqm/fixed) ---
  function getOptionsPriceTotalForActive(container) {
    let extras = 0;
    const area = getAreaFromContainer(container);
    // tylko JEDNA zaznaczona w każdej .opcje (wg Twojej logiki)
    document.querySelectorAll(".pole-wyboru .opcje").forEach(group => {
      const checked = group.querySelector('input[type="checkbox"]:checked');
      if (!checked) return;
      const type  = (checked.dataset.type || "fixed").toLowerCase();
      const price = parseFloat(checked.dataset.price || "0") || 0;
      extras += (type === "sqm") ? Math.round(price * area) : Math.round(price);
    });
    return extras;
  }

  // --- uruchamianie przeliczeń w aktywnym kontenerze ---
  function updateCalculatorForAll() {
    const active = document.querySelector(".build-container.active");
    if (!active) return;
    const id = active.id.replace("container", "");
    updateCalculator(id);
  }

  // --- PATCH Twojej istniejącej funkcji: dopłaty + NA ŻYWO nawiasy (+… zł) ---
  const oldUpdateCalculator = window.updateCalculator;
  window.updateCalculator = function (containerId) {
    // 1) najpierw Twoja baza (m² × stawka) + wypisanie ceny bazowej
    oldUpdateCalculator(containerId);

    // 2) kontener, m² i dopłaty
    const container   = document.getElementById(`container${containerId}`);
    if (!container) return;
    const priceTarget = container.querySelector(`#priceEstimate${containerId}`);

    const area = getAreaFromContainer(container);
    let extras = 0;

    // 3) W KAŻDEJ grupie usuń stare .price-tag, policz dopłatę i wstaw aktualny „(+… zł)”
    document.querySelectorAll(".pole-wyboru .opcje").forEach(group => {
      const checked = group.querySelector('input[type="checkbox"]:checked');

      // usuń wszystkie stare tagi w tej grupie
      group.querySelectorAll(".price-tag").forEach(tag => tag.remove());

      if (!checked) return;

      const type  = (checked.dataset.type || "fixed").toLowerCase();
      const price = parseFloat(checked.dataset.price || "0") || 0;
      const add   = (type === "sqm") ? Math.round(price * area) : Math.round(price);
      extras += add;

      // dopisz aktualny tag przy zaznaczonej opcji
      const label = checked.closest("label");
      if (label) {
        const span = document.createElement("span");
        span.className = "price-tag";
        span.textContent = ` (+${add.toLocaleString("pl-PL")} zł)`;
        label.appendChild(span);
      }
    });

    // 4) dolicz dopłaty do ceny bazowej
    if (priceTarget) {
      const baseText = priceTarget.textContent.replace(/\D/g, "");
      if (baseText) {
        const base  = parseInt(baseText, 10) || 0;
        const final = base + extras;
        priceTarget.textContent = final.toLocaleString("pl-PL") + " zł";
      }
    }
  };
});
</script>





<script>
document.addEventListener("DOMContentLoaded", () => {
  // m² aktywnego kontenera (badge → suwaki)
  function getActiveArea() {
    const active = document.querySelector(".build-container.active");
    if (!active) return 0;

    const badge = active.querySelector(".area-badge");
    if (badge && badge.textContent.trim()) {
      const m = badge.textContent.match(/([\d.,]+)/);
      if (m) {
        const v = parseFloat(m[1].replace(",", "."));
        if (!isNaN(v)) return v;
      }
    }
    const w = parseFloat(active.querySelector('input[id^="widthRange"]')?.value || "0");
    const l = parseFloat(active.querySelector('input[id^="lengthRange"]')?.value || "0");
    return (isNaN(w) || isNaN(l)) ? 0 : w * l;
  }

  // Pomocnicze: usuń wszystkie price-tagi w danym kontenerze .opcje
  function clearPriceTags(opcjeEl) {
    opcjeEl.querySelectorAll(".price-tag").forEach(tag => tag.remove());
  }

  // Obsługa każdej sekcji .pole-wyboru
  document.querySelectorAll(".pole-wyboru").forEach(pole => {
    const mainCheckbox = pole.querySelector(".main-check");
    const opcje = pole.querySelector(".opcje");
    if (!opcje) return;

    const subOptions = opcje.querySelectorAll('input[type="checkbox"]');

    // Main-check: ukryj/pokaż + resetuj opcje i price-tagi przy odznaczeniu
    if (mainCheckbox) {
      mainCheckbox.addEventListener("change", () => {
        if (!mainCheckbox.checked) {
          subOptions.forEach(c => (c.checked = false));
          clearPriceTags(opcje);
        }
        if (typeof updateCalculatorForAll === "function") updateCalculatorForAll();
      });
    }

    // Opcje: tylko jedna zaznaczona w ramach danej grupy + dopisz dynamiczny (+price)
    subOptions.forEach(opt => {
      opt.addEventListener("change", () => {
        const label = opt.closest("label");
        if (!label) return;

        // wyczyść stare tagi w tej grupie
        clearPriceTags(opcje);

        if (opt.checked) {
          // odznacz inne w tej samej grupie
          subOptions.forEach(o => { if (o !== opt) o.checked = false; });

          const type   = (opt.dataset.type || "fixed").toLowerCase();
          const price  = parseFloat(opt.dataset.price || "0") || 0;
          const area   = getActiveArea();
          const value  = Math.round(type === "sqm" ? price * area : price);

          const span = document.createElement("span");
          span.className = "price-tag";
          span.textContent = ` (+${value.toLocaleString("pl-PL")} zł)`;
          label.appendChild(span);
        }

        if (typeof updateCalculatorForAll === "function") updateCalculatorForAll();
      });
    });
  });
});
</script>







      <!-- Formularz kontaktowy -->

<!-- Contact -->
<section id="contact" class="full-screen-section d-flex align-items-center justify-content-center text-center">
  <div class="container" style="max-width: 600px;">
    <h2 class="section-title">Skontaktuj się z nami</h2>

    <div class="footer-description">
      <p>Telefon: <a href="tel:+48503702467">+48 503 702 467</a> | <a href="tel:+48500156450">+48 500 156 450</a></p>
      <p>Email: <a href="mailto:adam@zabudo.pl">adam@zabudo.pl</a></p>
    </div>

    <!-- Formularz kontaktowy -->
    <form id="contact-form" method="POST" action="/api/contact" novalidate>
      <div class="mb-2">
        <input type="text" name="user_name" placeholder="Imię i nazwisko" class="form-control" required />
      </div>
      <div class="mb-2">
        <input type="email" name="user_email" placeholder="Adres e-mail" class="form-control" required />
      </div>
      <div class="mb-2">
        <textarea id="message" name="message" rows="6" class="form-control" required>
Dzień dobry! Interesuje mnie budynek o wymiarach 3.5 x 5.5 m na terenie (wpisz miejscowość). Proszę o jak najszybszą odpowiedź.
        </textarea>
      </div>

      <!-- Turnstile (Captcha) -->
      <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer></script>
      <div class="cf-turnstile"
           data-sitekey="0x4AAAAAAB5Dri7HbhagljpE"
           data-theme="light"
           data-language="pl"></div>

      <button type="submit" class="btn btn-primary">Wyślij wiadomość</button>
      <a href="tel:+48503702467" class="btn btn-primary">Zadzwoń teraz!</a>
    </form>

    <p id="form-message" style="margin-top: 10px;"></p>
  </div>
</section>


 <!-- OBSŁUGO FORMULARZA EMAIL -->


<script>


(function() {
  const SERVICE_ENDPOINT = '/api/contact'; // to samo co action w <form>

  function addHidden(form, name, value) {
    let input = form.querySelector('input[name="'+name+'"]');
    if (!input) {
      input = document.createElement('input');
      input.type = 'hidden';
      input.name = name;
      form.appendChild(input);
    }
    input.value = value;
  }

  // —— zbierz konfigurację budynku (wykorzystuje Twoje funkcje, jeśli są) ——
  function appendBuildConfigurationToMessage(form) {
    try {
      const messageField = form.querySelector('textarea[name="message"]');
      if (!messageField) return;

      const build = (typeof collectActiveBuildConfig === 'function') ? collectActiveBuildConfig() : null;
      const services = (typeof collectServicesConfig === 'function') ? collectServicesConfig(document) : [];

      const lines = [];
      if (build) {
        if (build.buildType) lines.push(`Typ: ${build.buildType}`);
        if (Number.isFinite(build.width) && Number.isFinite(build.length)) {
          lines.push(`Wymiary: ${build.width.toFixed(1)} × ${build.length.toFixed(1)} m`);
        }
        if (Number.isFinite(build.height_eave)) lines.push(`Wysokość (najniższy pkt): ${build.height_eave.toFixed(1)} m`);
        if (Number.isFinite(build.height_peak)) lines.push(`Wysokość (najwyższy pkt): ${build.height_peak.toFixed(1)} m`);
        if (build.shownPrice) lines.push(`Szacunkowa cena: ${build.shownPrice}`);
      }
      if (Array.isArray(services) && services.length) {
        services.forEach(s => {
          const label = s?.selected?.label || '(brak wyboru)';
          const group = s?.group || 'Opcja';
          lines.push(`${group}: ${label}`);
        });
      }

      if (lines.length) {
        const konfTxt =
          '\n\nPełna konfiguracja budynku:\n' +
          lines.map(l => `• ${l}`).join('\n');

        const baseMsg = messageField.value || '';
        const marker = '(wpisz miejscowość)';

        if (baseMsg.includes(marker)) {
          const pos = baseMsg.indexOf(marker) + marker.length;
          messageField.value = baseMsg.slice(0, pos) + konfTxt + baseMsg.slice(pos);
        } else {
          messageField.value = baseMsg.replace(/\s+$/,'') + konfTxt;
        }
      }
    } catch (err) {
      console.warn('Nie udało się dołączyć konfiguracji do wiadomości:', err);
    }
  }

  // —— dopnij zgody z localStorage ——
  function appendConsents(form) {
    // newsletter
    let newsletterConsent = 'NIE', newsletterTs = '', newsletterSource = '';
    try {
      const meta = JSON.parse(localStorage.getItem('newsletterConsentMeta') || '{}');
      if (meta?.consent) {
        newsletterConsent = 'TAK';
        newsletterTs = meta.ts || '';
        newsletterSource = meta.source || '';
      }
    } catch (e) {}

    let cookiesConsent = 'NIE';
    try {
      const cons = JSON.parse(localStorage.getItem('consents') || '{}');
      cookiesConsent = cons.cookies ? 'TAK' : 'NIE';
    } catch (e) {}

    addHidden(form, 'newsletter_consent', newsletterConsent);
    addHidden(form, 'newsletter_consent_ts', newsletterTs);
    addHidden(form, 'newsletter_consent_source', newsletterSource);
    addHidden(form, 'consent_cookies', cookiesConsent);
  }

  // —— obsługa submitu ——
  function wireContactForm(form, msgEl) {
    if (!form) return;
    const msg = msgEl || document.getElementById('form-message');

    if (form.__wired__) return;
    form.__wired__ = true;

    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      // 1) UX: sprawdź lokalnie token Turnstile (backend i tak sprawdzi jeszcze raz)
      const tokenInput = form.querySelector('input[name="cf-turnstile-response"]');
      if (!tokenInput || !tokenInput.value) {
        if (msg) { msg.textContent = 'Zaznacz zabezpieczenie (captcha).'; msg.style.color = 'red'; }
        return;
      }

      // 2) dopnij zgody + konfigurację
      appendConsents(form);
      appendBuildConfigurationToMessage(form);

      // 3) spinner
      const btn = form.querySelector('button[type="submit"]');
      const original = btn ? btn.innerHTML : '';
      if (btn) { btn.disabled = true; btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Wysyłam…'; }

      // 4) fetch do backendu (FormData)
      try {
        const fd = new FormData(form);
        const resp = await fetch(SERVICE_ENDPOINT, {
          method: 'POST',
          body: fd,
          headers: { 'X-Requested-With': 'XMLHttpRequest' }
        });

        let json = {};
        try { json = await resp.json(); } catch(_) {}

        if (!resp.ok || json.ok === false) {
          if (msg) { msg.textContent = 'Nie udało się wysłać. Sprawdź dane i captcha.'; msg.style.color = 'red'; }
        } else {
          if (msg) { msg.textContent = 'Dziękujemy! Wiadomość wysłana.'; msg.style.color = 'green'; }
          form.reset();
          // zresetuj Turnstile po sukcesie
          if (window.turnstile) turnstile.reset();
        }
      } catch (err) {
        if (msg) { msg.textContent = 'Błąd sieci/serwera. Spróbuj ponownie.'; msg.style.color = 'red'; }
      } finally {
        if (btn) { btn.disabled = false; btn.innerHTML = original; }
      }
    });
  }

  // — init —
  document.addEventListener('DOMContentLoaded', function () {
    const pageForm = document.getElementById('contact-form');
    const pageMsg  = document.getElementById('form-message');
    if (pageForm) wireContactForm(pageForm, pageMsg);
  });
})();
</script>





</div>

<script>
function updateBuildingElevation() {
  const active = document.querySelector('.build-container.active');
  if (!active) return;

  const id = active.id.replace('container',''); // "1" lub "2"

  // --- ŚCIEŻKI DO GRAFIK ---
  const WALL_IMG_C1 = 'elewacjag1.webp';
  const ROOF_IMG_C1 = 'elewacjag1.webp';
  const WALL_IMG_C2 = 'elewacjag1.webp';
  const ROOF_IMG_C2 = 'elewacjag1.webp';
  const EDGE_IMG    = 'tekstura.webp';
  const GROUND_IMG  = 'beton.webp';
  const CAP_IMG = 'tekstura.webp'; 

  const SIDE_GAP = 16; // px luzu z lewej i prawej, żeby dach „wystawał”

  const baseInput       = active.querySelector(`#widthRange${id}`);
  const heightEaveInput = active.querySelector(`#heightRange${id}`);
  const heightPeakInput = active.querySelector(`#heightPeakRange${id}`);
  const map             = active.querySelector('.building-map-height');
  if (!baseInput || !heightEaveInput || !heightPeakInput || !map) return;

  let L      = parseFloat(baseInput.value || '0');
  let H_eave = parseFloat(heightEaveInput.value || '0');
  let H_peak = parseFloat(heightPeakInput.value || '0');

  // gwarancja: kalenica >= okap
  if (H_peak < H_eave) {
    H_peak = H_eave;
    heightPeakInput.value = H_peak.toFixed(1);
  }

  // odśwież spany z wartościami
  const eaveSpan = active.querySelector(`#heightValue${id}`);
  const peakSpan = active.querySelector(`#heightPeakValue${id}`);
  if (eaveSpan) eaveSpan.textContent = Number(heightEaveInput.value).toFixed(1);
  if (peakSpan) peakSpan.textContent = Number(heightPeakInput.value).toFixed(1);

  // --- SKALA RYSUNKU ---
  const PX = 45; // px na metr
  const basePx = Math.max(80, Math.round(L * PX));
  const peakPx = Math.max(100, Math.round(H_peak * PX));

  map.innerHTML = '';

  const SVGN = 'http://www.w3.org/2000/svg';
  const EDGE_THICK = 14;
  const CAP_LEN    = 10;
  const MARGIN_TOP = EDGE_THICK * 2;
  const MARGIN_BOTTOM = 20;

  const svg = document.createElementNS(SVGN, 'svg');
  svg.setAttribute('viewBox', `0 -${MARGIN_TOP} ${basePx} ${peakPx + MARGIN_TOP + MARGIN_BOTTOM}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
  svg.style.width  = basePx + 'px';
  svg.style.height = (peakPx + MARGIN_TOP + MARGIN_BOTTOM) + 'px';

  const yGround = peakPx;
  const yEave  = peakPx - Math.round(H_eave * PX);
  const yPeak  = peakPx - Math.round(H_peak * PX);
  const xMid   = Math.round(basePx / 2);

  // --- GRUNT ---
  const groundHeight = 6;
  const groundPatId = `groundPat-${id}-${Date.now()}`;
  const defsGround = document.createElementNS(SVGN, 'defs');
  const patGround = document.createElementNS(SVGN, 'pattern');
  patGround.setAttribute('id', groundPatId);
  patGround.setAttribute('patternUnits', 'userSpaceOnUse');
  patGround.setAttribute('width', basePx);
  patGround.setAttribute('height', groundHeight);

  const groundImg = document.createElementNS(SVGN, 'image');
  groundImg.setAttribute('href', GROUND_IMG);
  groundImg.setAttribute('x', 0);
  groundImg.setAttribute('y', 0);
  groundImg.setAttribute('width', basePx);
  groundImg.setAttribute('height', groundHeight);
  groundImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');

  patGround.appendChild(groundImg);
  defsGround.appendChild(patGround);
  svg.appendChild(defsGround);

  const groundRect = document.createElementNS(SVGN, 'rect');
  groundRect.setAttribute('x', 0);
  groundRect.setAttribute('y', yGround);
  groundRect.setAttribute('width', basePx);
  groundRect.setAttribute('height', groundHeight);
  groundRect.setAttribute('fill', `url(#${groundPatId})`);

  // --- ŚCIANA (pattern – „deski” się nie rozciągają) ---
  const WALL_IMG = (id === '2') ? WALL_IMG_C2 : WALL_IMG_C1;

  const pxPerM = PX;
  const BOARD_H_M = 0.05; // ~14 cm wysokości jednej „deski”
  const boardPx = Math.max(2, Math.round(BOARD_H_M * pxPerM));
  const BOARDS_PER_TILE = 4;
  const tileHeightPx = boardPx * BOARDS_PER_TILE;
  const tileWidthPx  = Math.max(80, Math.min(320, Math.round(basePx / 3)));

  const wallPatId = `wallPat-${id}-${Date.now()}`;
  const defsWall = document.createElementNS(SVGN, 'defs');
  const wallPat = document.createElementNS(SVGN, 'pattern');
  wallPat.setAttribute('id', wallPatId);
  wallPat.setAttribute('patternUnits', 'userSpaceOnUse');
  wallPat.setAttribute('width',  tileWidthPx);
  wallPat.setAttribute('height', tileHeightPx);

  const woodImg = document.createElementNS(SVGN, 'image');
  woodImg.setAttribute('href', WALL_IMG);
  woodImg.setAttribute('x', 0);
  woodImg.setAttribute('y', 0);
  woodImg.setAttribute('width',  tileWidthPx);
  woodImg.setAttribute('height', tileHeightPx);
  woodImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');

  wallPat.appendChild(woodImg);
  defsWall.appendChild(wallPat);
  svg.appendChild(defsWall);

  const wallRect = document.createElementNS(SVGN, 'rect');
  wallRect.setAttribute('x', SIDE_GAP);
  wallRect.setAttribute('y', yEave);
  wallRect.setAttribute('width', basePx - 2*SIDE_GAP);
  wallRect.setAttribute('height', (yGround - yEave));
  wallRect.setAttribute('fill', `url(#${wallPatId})`);

  const wallTopLine = document.createElementNS(SVGN, 'line');
  wallTopLine.setAttribute('x1', SIDE_GAP);
  wallTopLine.setAttribute('y1', yEave);
  wallTopLine.setAttribute('x2', basePx - SIDE_GAP);
  wallTopLine.setAttribute('y2', yEave);
  wallTopLine.setAttribute('stroke', 'black');
  wallTopLine.setAttribute('stroke-width', '1');

  // --- DACH (pattern – „belki” się nie rozciągają) ---
  const ROOF_IMG = (id === '2') ? ROOF_IMG_C2 : ROOF_IMG_C1;
  const roofPoints = `0,${yEave} ${xMid},${yPeak} ${basePx},${yEave}`;

  const BEAM_STEP_M = 0.18; // ~18 cm między „belkami”
  const beamPx = Math.max(6, Math.round(BEAM_STEP_M * PX));
  const roofTileH = beamPx;
  const roofTileW = Math.max(80, Math.min(320, Math.round(basePx / 3)));

  const roofPatId = `roofPat-${id}-${Date.now()}`;
  const defsRoof  = document.createElementNS(SVGN, 'defs');
  const roofPat   = document.createElementNS(SVGN, 'pattern');
  roofPat.setAttribute('id', roofPatId);
  roofPat.setAttribute('patternUnits', 'userSpaceOnUse');
  roofPat.setAttribute('width',  roofTileW);
  roofPat.setAttribute('height', roofTileH);

  const roofTex = document.createElementNS(SVGN, 'image');
  roofTex.setAttribute('href', ROOF_IMG);
  roofTex.setAttribute('x', 0);
  roofTex.setAttribute('y', 0);
  roofTex.setAttribute('width',  roofTileW);
  roofTex.setAttribute('height', roofTileH);
  roofTex.setAttribute('preserveAspectRatio', 'xMidYMid slice');

  // (opcjonalnie) obróć wzór pod spadek połaci:
  // const rise = H_peak - H_eave;
  // const halfWm = (basePx / 2) / PX;
  // const angleDeg = Math.atan2(rise, halfWm) * 180 / Math.PI;
  // roofPat.setAttribute('patternTransform', `rotate(${angleDeg}, ${xMid}, ${yPeak})`);

  roofPat.appendChild(roofTex);
  defsRoof.appendChild(roofPat);
  svg.appendChild(defsRoof);

  const roofPoly = document.createElementNS(SVGN, 'polygon');
  roofPoly.setAttribute('points', roofPoints);
  roofPoly.setAttribute('fill', `url(#${roofPatId})`);

  

  // ClipPath, który ogranicza cień do obszaru ściany (desek)
const wallClipId = `wallClip-${id}-${Date.now()}`;
const defsClip   = document.createElementNS(SVGN, 'defs');
const wallClip   = document.createElementNS(SVGN, 'clipPath');
wallClip.setAttribute('id', wallClipId);
wallClip.setAttribute('clipPathUnits', 'userSpaceOnUse');

const wallClipRect = document.createElementNS(SVGN, 'rect');
wallClipRect.setAttribute('x', SIDE_GAP);
wallClipRect.setAttribute('y', yEave);
wallClipRect.setAttribute('width', basePx - 2*SIDE_GAP);
wallClipRect.setAttribute('height', (yGround - yEave));

wallClip.appendChild(wallClipRect);
defsClip.appendChild(wallClip);
svg.appendChild(defsClip);

// --- PROSTY CLIP: cień tylko powyżej linii okapu (yEave) ---
const shadowClipId = `shadowClip-${id}-${Date.now()}`;
{
  const defsClipShadow = document.createElementNS(SVGN, 'defs');
  const clip = document.createElementNS(SVGN, 'clipPath');
  clip.setAttribute('id', shadowClipId);
  clip.setAttribute('clipPathUnits', 'userSpaceOnUse');

  const r = document.createElementNS(SVGN, 'rect');
  r.setAttribute('x', 0);
r.setAttribute('y', -MARGIN_TOP);   
  r.setAttribute('width', basePx);
r.setAttribute('height', yEave + MARGIN_TOP);

  clip.appendChild(r);
  defsClipShadow.appendChild(clip);
  svg.appendChild(defsClipShadow);
}


  // --- WIATROWNICE ---
  const A_left  = { x: 0,      y: yEave };
  const P_peak  = { x: xMid,   y: yPeak };
  const A_right = { x: basePx, y: yEave };

  const defs2 = document.createElementNS(SVGN, 'defs');
  const patId = `edgePat-${id}-${Date.now()}`;
  const pat = document.createElementNS(SVGN, 'pattern');
  pat.setAttribute('id', patId);
  pat.setAttribute('patternUnits', 'userSpaceOnUse');
  pat.setAttribute('width', basePx);
  pat.setAttribute('height', EDGE_THICK);

  const patImg = document.createElementNS(SVGN, 'image');
  patImg.setAttribute('href', EDGE_IMG);
  patImg.setAttribute('x', 0);
  patImg.setAttribute('y', 0);
  patImg.setAttribute('width', basePx);
  patImg.setAttribute('height', EDGE_THICK);
  patImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');

  pat.appendChild(patImg);
  defs2.appendChild(pat);
  svg.appendChild(defs2);

  function makeStrip(ax, ay, bx, by, thickness, capLen) {
    const vx = bx - ax, vy = by - ay;
    const len = Math.hypot(vx, vy) || 1;
    const ux = vx / len, uy = vy / len;
    const bxExt = bx + ux * capLen;
    const byExt = by + uy * capLen;
    const nx = -uy * thickness;
    const ny =  ux * thickness;
    return [
      `${ax},${ay}`,
      `${bxExt},${byExt}`,
      `${bxExt+nx},${byExt+ny}`,
      `${ax+nx},${ay+ny}`
    ].join(' ');
  }

// --- CIEŃ DLA WIATROWNIC I KAPTURKA ---
const edgeShadowId = `edgeShadow-${id}-${Date.now()}`;
const defsShadow   = document.createElementNS(SVGN, 'defs');
const shadowFilter = document.createElementNS(SVGN, 'filter');
shadowFilter.setAttribute('id', edgeShadowId);
// powiększ obszar filtra, by cień się nie ucinał
shadowFilter.setAttribute('x', '-20%');
shadowFilter.setAttribute('y', '-20%');
shadowFilter.setAttribute('width', '140%');
shadowFilter.setAttribute('height', '160%');
shadowFilter.setAttribute('color-interpolation-filters', 'sRGB');

// Prosty, wydajny cień:
const feDrop = document.createElementNS(SVGN, 'feDropShadow');
feDrop.setAttribute('dx', '0');              // przesunięcie w poziomie
feDrop.setAttribute('dy', '8');              // przesunięcie w pionie
feDrop.setAttribute('stdDeviation', '4');    // miękkość
feDrop.setAttribute('flood-color', 'rgba(0,0,0,0.77)'); // kolor/alpha cienia

shadowFilter.appendChild(feDrop);
defsShadow.appendChild(shadowFilter);
svg.appendChild(defsShadow);

  const leftStrip = document.createElementNS(SVGN, 'polygon');
  leftStrip.setAttribute('points', makeStrip(A_left.x, A_left.y, P_peak.x, P_peak.y, -EDGE_THICK, CAP_LEN));
  leftStrip.setAttribute('fill', `url(#${patId})`);

  const rightStrip = document.createElementNS(SVGN, 'polygon');
  rightStrip.setAttribute('points', makeStrip(A_right.x, A_right.y, P_peak.x, P_peak.y, EDGE_THICK, CAP_LEN));
  rightStrip.setAttribute('fill', `url(#${patId})`);



  // PATTERN tylko dla kapturka (nie używa EDGE_IMG)
const capPatId = `capPat-${id}-${Date.now()}`;
{
  const defsCap  = document.createElementNS(SVGN, 'defs');
  const capPat   = document.createElementNS(SVGN, 'pattern');
  capPat.setAttribute('id', capPatId);
  capPat.setAttribute('patternUnits', 'userSpaceOnUse');
  capPat.setAttribute('width',  basePx);
  capPat.setAttribute('height', EDGE_THICK * 2.2); // zbliżone do capHeight

  const capImg = document.createElementNS(SVGN, 'image');
  capImg.setAttribute('href', CAP_IMG);
  capImg.setAttribute('x', 0);
  capImg.setAttribute('y', 0);
  capImg.setAttribute('width',  basePx);
  capImg.setAttribute('height', EDGE_THICK * 2.2);
  capImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');

  capPat.appendChild(capImg);
  defsCap.appendChild(capPat);
  svg.appendChild(defsCap);
}
// --- KAPTUREK ---
const capWidth  = EDGE_THICK * 3;
const capHeight = EDGE_THICK * 2.2;
const capOffsetY = 5;

const ridgeCap = document.createElementNS(SVGN, 'polygon');
ridgeCap.setAttribute(
  'points',
  `${P_peak.x},${P_peak.y - capHeight + capOffsetY} ` +
  `${P_peak.x - capWidth/2},${P_peak.y + capOffsetY} ` +
  `${P_peak.x + capWidth/2},${P_peak.y + capOffsetY}`
);
// BYŁO: ridgeCap.setAttribute('fill', `url(#${patId})`);
ridgeCap.setAttribute('fill', `url(#${capPatId})`); // <-- teraz używa CAP_IMG



leftStrip.setAttribute('filter', `url(#${edgeShadowId})`);
rightStrip.setAttribute('filter', `url(#${edgeShadowId})`);

// ⬇️ to dopisz:
leftStrip.setAttribute('clip-path', `url(#${shadowClipId})`);
rightStrip.setAttribute('clip-path', `url(#${shadowClipId})`);



  // --- KOLEJNOŚĆ ---
  svg.append(
    groundRect,
    wallRect, wallTopLine, // ściana: pattern z luzem po bokach
    roofPoly,              // dach: pattern (tiling)
    rightStrip, leftStrip, ridgeCap
  );

  map.appendChild(svg);
}
</script>





<script>

document.addEventListener('DOMContentLoaded', function () {
  // Nasłuchujemy kliknięcia na kartach w container5
  const cards = document.querySelectorAll('.container5-cards .card');

  // Funkcja aktualizująca formularz po kliknięciu na kartę
  cards.forEach(card => {
    card.addEventListener('click', function (e) {
          if (e.target.closest('.carousel')) return; 
      // Pobieramy tytuł i wymiary z atrybutów data- na karcie
      const title = card.getAttribute('data-title');
      const dimensions = card.getAttribute('data-dimensions');

      // Ustawiamy odpowiednią nazwę budynku w formularzu
      const buildingNameField = document.querySelector('textarea[name="message"]');
      buildingNameField.value = `Dzień dobry! Interesuje mnie ${title} z dostawą do (wpisz miejscowość). Proszę o jak najszybszą odpowiedź.`;

      // Usuwamy fragment o wymiarach z formularza
      const dimensionsField = document.getElementById('dimensions1');
      if (dimensionsField) {
        dimensionsField.style.display = 'none';  // Ukrywamy wymiary
      }

      // Ustawiamy tytuł budynku
      const titleField = document.querySelector('.contact-name');
      if (titleField) {
        titleField.textContent = title;  // Ustawiamy tytuł budynku
      }
    });
  });
});

// Funkcja do przewijania do sekcji "Dimensions"
const scrollTrigger = document.getElementById('scrollToDimensions');
const target = document.getElementById('oferta');

if (scrollTrigger && target) {
  scrollTrigger.addEventListener('click', (e) => {
    e.preventDefault();
    const yOffset = -60; // Offset dla górnej krawędzi
    const y = target.getBoundingClientRect().top + window.scrollY + yOffset;
    window.scrollTo({ top: y, behavior: 'smooth' });
  });
}


// Funkcja do uzupełniania treści wiadomości
function updateMessageText() {
  const activeContainer = document.querySelector('.build-container.active');
  if (!activeContainer) return;

  // Pobranie danych z suwaków
  const width  = activeContainer.querySelector('input[id^="widthRange"]')?.value || '?';
  const length = activeContainer.querySelector('input[id^="lengthRange"]')?.value || '?';
  const eave   = activeContainer.querySelector('input[id^="heightRange"]')?.value || '';
  const peak   = activeContainer.querySelector('input[id^="heightPeakRange"]')?.value || '';

  // Pole wiadomości
  const messageField = document.getElementById('message');
  if (!messageField) return;

  // Typ budynku (z burger menu)
  let containerName = 'Narzędziówka';
  document.querySelectorAll("#burgerMenu button[data-target]").forEach(button => {
    if (button.classList.contains('active')) {
      containerName = button.textContent.trim();
    }
  });

  // Podstawowa treść
  let baseMsg = `Dzień dobry! Interesuje mnie ${containerName} o wymiarach ${width} × ${length} m na terenie (wpisz miejscowość). Proszę o jak najszybszą odpowiedź.`;

  // Pełna konfiguracja
  const lines = [];
  if (width && length) lines.push(`Wymiary: ${width} × ${length} m`);
  if (eave) lines.push(`Okap: ${parseFloat(eave).toFixed(1)} m`);
  if (peak) lines.push(`Kalenica: ${parseFloat(peak).toFixed(1)} m`);

// helper: tytuł grupy (bez checkboxa)
function getGroupTitleFrom(chk) {
  const group = chk.closest('.pole-wyboru');
  if (!group) return '';
  const titleEl = group.querySelector('.pole-wyboru-tytuł');
  if (!titleEl) return '';
  const clone = titleEl.cloneNode(true);
  const inp = clone.querySelector('input');
  if (inp) inp.remove();
  return clone.textContent.trim().replace(/\s+/g, ' ');
}

// Opcje dodatkowe (z nazwą grupy + etykietą)
document.querySelectorAll('.usługi-menu-wyboru input[type=checkbox]:checked').forEach(chk => {
  // nazwa grupy (np. "Ocieplenie", "Fundament")
  const groupTitle = getGroupTitleFrom(chk);

  // etykieta opcji (np. "150 mm"), bez dopisków (+... zł) i bez "on"
  let optLabel = '';
  const labelEl = chk.closest('label');
  if (labelEl) {
    const clone = labelEl.cloneNode(true);
    clone.querySelectorAll('input, .price-tag').forEach(n => n.remove()); // wytnij input i dynamiczne ceny
    optLabel = clone.textContent.trim()
      .replace(/\(\+\s*[\d\s.,]+ zł\)\s*$/i, ''); // usuń "(+ ... zł)" z końca
  }
  if (!optLabel || optLabel.toLowerCase() === 'on') {
    optLabel = (chk.value && chk.value.toLowerCase() !== 'on') ? chk.value : '';
  }

  if (groupTitle && optLabel) {
    lines.push(`Opcja: ${groupTitle} ${optLabel}`);
  } else if (optLabel) {
    lines.push(`Opcja: ${optLabel}`);
  }
});

  // Dopisz konfigurację jeśli są jakieś linie
  if (lines.length) {
    baseMsg += "\n\nPełna konfiguracja budynku:\n" + lines.map(l => `• ${l}`).join("\n");
  }

  // Wstaw do pola wiadomości
  messageField.value = baseMsg;
}

// Funkcja do nasłuchiwania zmian na suwakach tylko dla aktywnego kontenera
function addEventListenersForActiveContainer() {
  const activeContainer = document.querySelector('.build-container.active');
  if (!activeContainer) return;

  // id = "1" dla container1, "2" dla container2 …
  const id = activeContainer.id.replace('container', '');

  // pobierz kontrolki z aktywnego kontenera (po konkretnych id)
  const widthRange  = activeContainer.querySelector(`#widthRange${id}`);
  const lengthRange = activeContainer.querySelector(`#lengthRange${id}`);
  const heightEave  = activeContainer.querySelector(`#heightRange${id}`);        // okap
  const heightPeak  = activeContainer.querySelector(`#heightPeakRange${id}`);    // kalenica

  // jedna funkcja odświeżająca wszystko co trzeba
  const refreshAll = () => {
    updateCalculator(id);
    updateBuildingMap();
    if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
  };

  // — suwaki planu (z góry)
  if (widthRange)  widthRange.addEventListener('input', refreshAll);
  if (lengthRange) lengthRange.addEventListener('input', refreshAll);

  // — suwaki wysokości (front)
  if (heightEave) heightEave.addEventListener('input', () => {
    if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
    updateCalculator(id); // cena zależy m.in. od okapu
  });

if (heightPeak) heightPeak.addEventListener('input', () => {
  if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
  updateCalculator(id); // TERAZ MUSI przeliczać, bo cena zależy od różnicy (peak-eave)
});

  // — reguła: kalenica ≥ okap + 0.2 (może być większa)
  const DELTA = 0.2;

  if (heightEave) {
    heightEave.addEventListener('input', () => {
      let eave   = parseFloat(heightEave.value);
      const peak = parseFloat(heightPeak?.value ?? '0');
      const peakMax = parseFloat(heightPeak?.max ?? '4');

      const eaveMaxAllowed = peakMax - DELTA;
if (eave > eaveMaxAllowed) {
  eave = eaveMaxAllowed;
  setRangeValue(heightEave, eave.toFixed(1)); // "live" update na suwaku + polu number
}

const minPeak = eave + DELTA;
if (heightPeak && peak < minPeak) {
  const corr = Math.min(minPeak, peakMax);
  setRangeValue(heightPeak, corr.toFixed(1)); // "live" update górnego + jego number
}
      if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
      updateCalculator(id);
    });
  }

if (heightPeak) {
  heightPeak.addEventListener('input', () => {
    const eave    = parseFloat(heightEave?.value ?? '0');
    let   peak    = parseFloat(heightPeak.value);
    const peakMax = parseFloat(heightPeak.max ?? '4');

const minPeak = eave + 0.2;
if (peak < minPeak) {
  peak = Math.min(minPeak, peakMax);
  setRangeValue(heightPeak, peak.toFixed(1)); // "live" update
}

    if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
    updateCalculator(id); // ← DODAJ TO
  });
}

  // od razu przelicz po wpięciu nasłuchów (ważne dla „na żywo”)
  refreshAll();
}

  // Ustawienie ceny za dach!

const ROOF_HYPO_FACTOR = 58;

// Ustawienie ceny za garaż dwustanowiskowy!

const BUILD_TYPE_SURCHARGE = {
  '1': 0,        // garaż jednostanowiskowy
  '2': 4873     // garaż dwustanowiskowy  ← ZMIEŃ KWOTĘ wg potrzeb
};

function calcRoofHypoCost(containerId, width, length) {
  // Szukamy suwaków wysokości tylko w tym kontenerze
  const cont = document.querySelector(`#container${containerId}`);
  if (!cont) return 0;

  const eaveInput = cont.querySelector(`#heightRange${containerId}`);
  const peakInput = cont.querySelector(`#heightPeakRange${containerId}`);

  // Jeśli w tym kontenerze nie ma suwaków wysokości → brak dopłaty
  if (!eaveInput || !peakInput) return 0;

  const eave = parseFloat(eaveInput.value);
  const peak = parseFloat(peakInput.value);
  if (!Number.isFinite(eave) || !Number.isFinite(peak) || !Number.isFinite(width) || !Number.isFinite(length)) return 0;

  // Różnica wysokości (wysokość samego dachu, „rise”)
  const rise = Math.max(peak - eave, 0);

  // Połowa szerokości („run”)
  const halfWidth = width / 2;

  // Przeciwprostokątna jednego spadu
  const hypo = Math.hypot(halfWidth, rise); // = sqrt(halfWidth^2 + rise^2)

  // Zgodnie z Twoim opisem:
  // 2 spady  → *2
  // × szerokość × długość
  // × współczynnik
  const rawCost = hypo * 2 * width * length * ROOF_HYPO_FACTOR;

  return Math.round(rawCost);
}


// Funkcja aktualizująca wartości w polach suwaków oraz treści
// Funkcja aktualizująca wartości w polach suwaków oraz treści
function updateCalculator(containerId) {
  const widthRange   = document.getElementById(`widthRange${containerId}`);
  const lengthRange  = document.getElementById(`lengthRange${containerId}`);
  const widthValue   = document.getElementById(`widthValue${containerId}`);
  const lengthValue  = document.getElementById(`lengthValue${containerId}`);
  const priceEstimate= document.getElementById(`priceEstimate${containerId}`);

  if (!widthRange || !lengthRange || !priceEstimate) return;

  const width  = parseFloat(widthRange.value)  || 0;
  const length = parseFloat(lengthRange.value) || 0;
  const area   = width * length;

  const pricePerSquareMeter = {
    container1: 318,
    container2: 318,
  };

  const baseRate = pricePerSquareMeter[`container${containerId}`] || 0;

  // Mnożnik z okapu (jeśli dany kontener go posiada)
  let heightMultiplier = 1;
  const eaveInput = document.querySelector(`#container${containerId} #heightRange${containerId}`);
  if (eaveInput) {
    const eave = parseFloat(eaveInput.value);
    if (Number.isFinite(eave) && eave > 0) heightMultiplier = eave;
  }

  // NOWE: dopłata za spad (przeciwprostokątna)
  const roofHypoCost = calcRoofHypoCost(containerId, width, length);

  const buildSurcharge = BUILD_TYPE_SURCHARGE[String(containerId)] || 0;

// Cena końcowa = bazowa * mnożnik wysokości + dopłata za spad + dopłata za typ
const estimatedPrice = Math.round(area * baseRate * heightMultiplier) 
                       + roofHypoCost 
                       + buildSurcharge;

  if (widthValue)   widthValue.textContent  = width.toFixed(1);
  if (lengthValue)  lengthValue.textContent = length.toFixed(1);
  priceEstimate.textContent = estimatedPrice.toLocaleString('pl-PL') + ' zł';

  if (typeof updateMessageText === 'function') updateMessageText();
}





function updateBuildingMap() {
  const activeContainer = document.querySelector('.build-container.active');
  if (!activeContainer) return;

  const width  = parseFloat(activeContainer.querySelector('input[id^="widthRange"]')?.value);
  const length = parseFloat(activeContainer.querySelector('input[id^="lengthRange"]')?.value);
  const buildingMap = activeContainer.querySelector('.building-map');

  if (!buildingMap || !Number.isFinite(width) || !Number.isFinite(length)) return;

  // 1rem w px (z CSS html { font-size: ... })
  const rootPx = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;

  // (opcjonalnie) twarde 75% na mobilkach
  const isMobile = window.matchMedia('(max-width: 576px)').matches;
  const scale = isMobile ? 0.75 : 1;

  // Twoje „piksele logiczne” × skala, a na końcu w rem
  const mapWidthPx  = width  * 45 * scale;
  const mapHeightPx = length * 45 * scale;

  const mapWidthRem  = mapWidthPx  / rootPx;
  const mapHeightRem = mapHeightPx / rootPx;

  buildingMap.style.width  = `${mapWidthRem}rem`;
  buildingMap.style.height = `${mapHeightRem}rem`;
  buildingMap.style.maxWidth  = '100%';
  buildingMap.style.maxHeight = '100%';
  buildingMap.style.overflow  = 'hidden';

  // === SVG z dwiema teksturami + kalenica ===
  const NS = 'http://www.w3.org/2000/svg';
  const TILE_W = 100;
  const TILE_H = 100;

  const LEFT_IMG   = 'dachl.webp';
  const RIGHT_IMG  = 'dach.webp';
  const RIDGE_IMG  = 'kalenica.webp';

  // wyczyść poprzedni rysunek
  buildingMap.innerHTML = '';

  const svg = document.createElementNS(NS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${mapWidthPx} ${mapHeightPx}`);
  svg.setAttribute('width', mapWidthPx);
  svg.setAttribute('height', mapHeightPx);
  svg.style.width = '100%';
  svg.style.height = '100%';
  svg.style.display = 'block';
  svg.style.background = '#fff';

  const defs = document.createElementNS(NS, 'defs');

  // --- lewa połać (pattern) ---
  const patLeftId  = `roofLeft-${Date.now()}`;
  const patLeft = document.createElementNS(NS, 'pattern');
  patLeft.setAttribute('id', patLeftId);
  patLeft.setAttribute('patternUnits', 'userSpaceOnUse');
  patLeft.setAttribute('width', TILE_W);
  patLeft.setAttribute('height', TILE_H);
  const imgLeft = document.createElementNS(NS, 'image');
  imgLeft.setAttribute('href', LEFT_IMG);
  imgLeft.setAttribute('x', 0);
  imgLeft.setAttribute('y', 0);
  imgLeft.setAttribute('width', TILE_W);
  imgLeft.setAttribute('height', TILE_H);
  imgLeft.setAttribute('preserveAspectRatio', 'xMidYMid slice');
  patLeft.appendChild(imgLeft);
  defs.appendChild(patLeft);

  // --- prawa połać (pattern) ---
  const patRightId = `roofRight-${Date.now()}`;
  const patRight = document.createElementNS(NS, 'pattern');
  patRight.setAttribute('id', patRightId);
  patRight.setAttribute('patternUnits', 'userSpaceOnUse');
  patRight.setAttribute('width', TILE_W);
  patRight.setAttribute('height', TILE_H);
  const imgRight = document.createElementNS(NS, 'image');
  imgRight.setAttribute('href', RIGHT_IMG);
  imgRight.setAttribute('x', 0);
  imgRight.setAttribute('y', 0);
  imgRight.setAttribute('width', TILE_W);
  imgRight.setAttribute('height', TILE_H);
  imgRight.setAttribute('preserveAspectRatio', 'xMidYMid slice');
  patRight.appendChild(imgRight);
  defs.appendChild(patRight);

  // --- kalenica (pattern z kontrolą gęstości przez liczbę powtórzeń) ---
  const RIDGE_REPEATS = 10; // więcej = gęściej
  const ridgeTileW = 32;
  const ridgeTileH = Math.max(6, Math.round(mapHeightPx / RIDGE_REPEATS));
  const ridgePatId = `ridgePat-${Date.now()}`;
  const ridgePat = document.createElementNS(NS, 'pattern');
  ridgePat.setAttribute('id', ridgePatId);
  ridgePat.setAttribute('patternUnits', 'userSpaceOnUse');
  ridgePat.setAttribute('width', ridgeTileW);
  ridgePat.setAttribute('height', ridgeTileH);
  const ridgeImg = document.createElementNS(NS, 'image');
  ridgeImg.setAttribute('href', RIDGE_IMG);
  ridgeImg.setAttribute('x', 0);
  ridgeImg.setAttribute('y', 0);
  ridgeImg.setAttribute('width', ridgeTileW);
  ridgeImg.setAttribute('height', ridgeTileH);
  ridgeImg.setAttribute('preserveAspectRatio', 'xMidYMid slice');
  ridgePat.appendChild(ridgeImg);
  defs.appendChild(ridgePat);

  svg.appendChild(defs);

  // cień
  const shadow = document.createElementNS(NS, 'rect');
  shadow.setAttribute('x', 3);
  shadow.setAttribute('y', 3);
  shadow.setAttribute('width', mapWidthPx);
  shadow.setAttribute('height', mapHeightPx);
  shadow.setAttribute('fill', 'rgba(0,0,0,0.06)');
  svg.appendChild(shadow);

  // podział na pół
  const midX = mapWidthPx / 2;

  // lewa połać
  const leftRect = document.createElementNS(NS, 'rect');
  leftRect.setAttribute('x', 0);
  leftRect.setAttribute('y', 0);
  leftRect.setAttribute('width', Math.ceil(midX) + 0.5);
  leftRect.setAttribute('height', mapHeightPx);
  leftRect.setAttribute('fill', `url(#${patLeftId})`);
  leftRect.setAttribute('stroke', '#111');
  leftRect.setAttribute('stroke-width', '2');
  svg.appendChild(leftRect);

  // prawa połać
  const rightRect = document.createElementNS(NS, 'rect');
  rightRect.setAttribute('x', Math.floor(midX) - 0.5);
  rightRect.setAttribute('y', 0);
  rightRect.setAttribute('width', Math.ceil(midX) + 0.5);
  rightRect.setAttribute('height', mapHeightPx);
  rightRect.setAttribute('fill', `url(#${patRightId})`);
  rightRect.setAttribute('stroke', '#111');
  rightRect.setAttribute('stroke-width', '2');
  svg.appendChild(rightRect);

  // pasek kalenicy

  const DENSITY_Y = 3; // 2 = gęściej
ridgePat.setAttribute('patternTransform', `scale(1, ${1 / DENSITY_Y})`);
  const RIDGE_W = 8; // grubość paska
  const ridge = document.createElementNS(NS, 'rect');
  ridge.setAttribute('x', midX - RIDGE_W / 2);
  ridge.setAttribute('y', 0);
  ridge.setAttribute('width', RIDGE_W);
  ridge.setAttribute('height', mapHeightPx);
  ridge.setAttribute('fill', `url(#${ridgePatId})`);
  svg.appendChild(ridge);

  // >>> WAŻNE: wstaw SVG do DOM
  buildingMap.appendChild(svg);
}

// Funkcja do ustawienia nasłuchiwania na kliknięcie przycisku w burger menu
function setUpBurgerMenu() {
  const buttons = document.querySelectorAll("#burgerMenu button[data-target]");
  const containers = document.querySelectorAll(".build-container");

  buttons.forEach(button => {
    button.addEventListener("click", () => {
      buttons.forEach((btn) => btn.classList.remove("active"));
      containers.forEach((c) => c.classList.remove("active"));

      button.classList.add("active");
      const targetId = button.getAttribute("data-target");
      const targetContainer = document.getElementById(targetId);
      if (targetContainer) {
        targetContainer.classList.add("active");
      }

      // ważne: najpierw ustaw nasłuchy, potem przelicz
      addEventListenersForActiveContainer();
      const newId = targetContainer.id.replace('container','');
      updateCalculator(newId);
      updateBuildingMap();
      if (typeof updateBuildingElevation === 'function') updateBuildingElevation();
    });
  });
}

// Inicjalizujemy nasłuch i aktualizacje mapki dla aktywnego kontenera
setUpBurgerMenu();
addEventListenersForActiveContainer();
updateCalculator('1');
updateBuildingMap();
updateBuildingElevation();







</script>
















  <!-- Footer -->
  <footer id="footer">
    <div class="container">
      <p>&copy; <span id="year"></span> Zabudo.pl</p>
              <p>NIP: 6252502129</p>
      <div class="footer-description">
        <p>Telefon: <a href="tel:+48503702467">+48 503 702 467</a> | <a href="tel:+48500156450">+48 500 156 450</a></p>
        <p>Email: <a href="mailto:adam@zabudo.pl">adam@zabudo.pl</a></p>
        <a href="polityka-prywatności.html">Polityka prywatności</a> | <a href="regulamin-sprzedaży.html">Regulamin sprzedaży</a>
      </div>
    </div>
  </footer>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>



  <!-- Twój główny skrypt (jeśli używasz) -->
  <script src="script.js"></script>


  <!-- BANER ZGÓD: HTML -->
  <div id="cookie-banner" class="text-center" style="display:none;">
    Ta strona korzysta z plików cookies w celach statystycznych i funkcjonalnych.
    <br>Możesz zaakceptować lub opuścić stronę, jeśli się nie zgadzasz.

    <div class="mt-3 text-start" style="max-width: 420px; margin: 0 auto;">
      <label><input type="checkbox" id="consent-cookies"> Zgadzam się na pliki cookies</label><br>
      <label><input type="checkbox" id="consent-newsletter"> Zgadzam się na otrzymywanie newslettera</label>
    </div>

    <div class="mt-3">
      <button id="accept-all" class="btn btn-success btn-sm me-2">✅ Zaakceptuj wszystkie</button>
      <button id="accept-cookies" class="btn btn-outline-secondary btn-sm">Zapisz wybór</button>
    </div>

    <!-- (Opcjonalnie) linki do polityk -->
    <!-- <div class="small mt-2"><a href="/polityka-prywatnosci">Polityka prywatności</a> • <a href="/polityka-cookies">Polityka cookies</a></div> -->
  </div>

  <!-- BANER ZGÓD: LOGIKA + integracja z EmailJS -->
  <script>
  // --- Ładowanie GA tylko przy zgodzie na cookies ---
  function loadAnalytics() {
    if (window._gaLoaded) return;
    const script = document.createElement('script');
    script.src = "https://www.googletagmanager.com/gtag/js?id=G-36X685CZ6N";
    script.async = true;
    document.head.appendChild(script);

    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    window.gtag = gtag;
    gtag('js', new Date());
    gtag('config', 'G-36X685CZ6N');
    window._gaLoaded = true;
  }

  document.addEventListener('DOMContentLoaded', function() {
    const banner = document.getElementById('cookie-banner');
    const btnAcceptAll = document.getElementById('accept-all');
    const btnSave = document.getElementById('accept-cookies');
    const consentCookies = document.getElementById('consent-cookies');
    const consentNewsletter = document.getElementById('consent-newsletter');

    // Przywróć zgody
    const saved = localStorage.getItem('consents');
    if (saved) {
      const consents = JSON.parse(saved);
      consentCookies.checked = !!consents.cookies;
      consentNewsletter.checked = !!consents.newsletter;
      if (consents.cookies) loadAnalytics();
      banner.style.display = 'none';
    } else {
      banner.classList.add('show');
      banner.style.display = '';
    }

    // Klik: zaakceptuj wszystkie
    btnAcceptAll.addEventListener('click', function() {
      consentCookies.checked = true;
      consentNewsletter.checked = true;
      saveAndClose();
    });

    // Klik: zapisz wybór
    btnSave.addEventListener('click', function() {
      saveAndClose();
    });

    function saveAndClose() {
      const consents = {
        cookies: !!consentCookies.checked,
        newsletter: !!consentNewsletter.checked
      };

      localStorage.setItem('consents', JSON.stringify(consents));

      // zapis metadanych zgody na newsletter (audyt)
      localStorage.setItem('newsletterConsentMeta', JSON.stringify({
        consent: consents.newsletter,
        ts: new Date().toISOString(),
        source: 'cookie-banner'
      }));

      if (consents.cookies) loadAnalytics();

      banner.classList.remove('show');
      banner.style.display = 'none';
    }
  });

</script>







<script>
// ZWIJANIE MENU MOBILNEGO + PŁYNNY SCROLL Z OFFSETEM
document.addEventListener('DOMContentLoaded', () => {
  const navbarCollapseEl = document.getElementById('navbarNav');
  const navbarToggler    = document.querySelector('.navbar-toggler');
  if (!navbarCollapseEl || !navbarToggler) return;

  // Instancja Collapse (nie otwieraj/nie zamykaj automatycznie)
  const bsCollapse = bootstrap.Collapse.getOrCreateInstance(navbarCollapseEl, { toggle: false });

  // Linki, które mają zamykać menu (zwykłe i dropdowny)
  const actionableLinks = navbarCollapseEl.querySelectorAll('a.nav-link, .dropdown-item');

  // Funkcja: czy jesteśmy w trybie mobilnym (toggler widoczny)
  const isMobile = () => window.getComputedStyle(navbarToggler).display !== 'none';

  // Płynny scroll z offsetem dla sekcji (#id)
  const smoothScrollToHash = (hash) => {
    if (!hash || hash === '#') return false;
    const target = document.querySelector(hash);
    if (!target) return false;
    const yOffset = -60; // wysokość nagłówka (dostosuj w razie potrzeby)
    const y = target.getBoundingClientRect().top + window.scrollY + yOffset;
    window.scrollTo({ top: y, behavior: 'smooth' });
    return true;
  };

  actionableLinks.forEach(link => {
    link.addEventListener('click', (e) => {
      const href = link.getAttribute('href') || '';

      // Jeśli klik w link do sekcji na stronie — przewiń z offsetem
      if (href.startsWith('#')) {
        e.preventDefault();
        smoothScrollToHash(href);
      }

      // Jeżeli menu jest rozwinięte i jesteśmy na mobile — zwiń
      if (isMobile() && navbarCollapseEl.classList.contains('show')) {
        bsCollapse.hide();
      }
    });
  });

  // Klik poza menu — zamknij (tylko mobile)
  document.addEventListener('click', (e) => {
    if (!isMobile()) return;
    const clickedInsideMenu = navbarCollapseEl.contains(e.target);
    const clickedToggler    = navbarToggler.contains(e.target);
    if (navbarCollapseEl.classList.contains('show') && !clickedInsideMenu && !clickedToggler) {
      bsCollapse.hide();
    }
  });

  // Zamykanie po nawigacji klawiaturą (Enter/Space na linku)
  navbarCollapseEl.addEventListener('keydown', (e) => {
    if (!isMobile()) return;
    if ((e.key === 'Enter' || e.key === ' ') && e.target.matches('a.nav-link, .dropdown-item')) {
      setTimeout(() => bsCollapse.hide(), 0);
    }
  });

  // Opcjonalnie: jeśli adres URL ma #hash po przeładowaniu — przewiń z offsetem
  if (location.hash) {
    setTimeout(() => smoothScrollToHash(location.hash), 0);
  }
});

</script>

  <script>
    // Rok w stopce
    document.getElementById('year').textContent = new Date().getFullYear();
  </script>





  








<script>
  // sklonuj formularz z aktualnymi wartościami
  function cloneFormIntoModal() {
    const slot = document.getElementById('modalFormSlot');
    const source = document.getElementById('contact-form');
    if (!slot || !source) return;

    // głęboka kopia
    const clone = source.cloneNode(true);

    // unikamy duplikatów ID w DOM:
    clone.id = 'contact-form-modal';
    // zmień potencjalne duplikaty ID pól wewnątrz (np. #message)
    clone.querySelectorAll('[id]').forEach(el => {
      el.id = el.id + '-modal';
    });

    // przenieś wartości (cloneNode nie przenosi dynamicznych .value pewnych elementów)
    const srcFields = source.querySelectorAll('input, textarea, select');
    const dstFields = clone.querySelectorAll('input, textarea, select');
    srcFields.forEach((s, i) => {
      const d = dstFields[i];
      if (!d) return;
      if (d.type === 'checkbox' || d.type === 'radio') d.checked = s.checked;
      else d.value = s.value;
    });

    // osobny „msg” dla modala
    let modalMsg = clone.querySelector('#form-message-modal');
    if (!modalMsg) {
      modalMsg = document.createElement('p');
      modalMsg.id = 'form-message-modal';
      modalMsg.style.marginTop = '10px';
      clone.appendChild(modalMsg);
    }

    // wstaw do slotu
    slot.innerHTML = '';
    slot.appendChild(clone);

    // podłącz funkcjonalność EmailJS do klona
    if (typeof wireContactForm === 'function') {
      wireContactForm(clone, modalMsg);
    }
  }

  // przy każdym otwarciu modala generuj PDF (jak masz) + wstaw klon formularza
  document.addEventListener('DOMContentLoaded', () => {
    const modalEl = document.getElementById('saveProjectModal');
    if (!modalEl) return;

    modalEl.addEventListener('shown.bs.modal', () => {
      // 1) PDF (masz już taki handler — ten może współistnieć)
      try { if (typeof buildPdfDoc === 'function') buildPdfDoc(); } catch(e){ console.error(e); }

      // 2) klon formularza
      try { cloneFormIntoModal(); } catch(e){ console.error('Błąd klonowania formularza:', e); }
    });
  });
</script>





<script>
/**
 * Dokleja pola <input type="number"> do wszystkich suwaków w .build-container,
 * synchronizuje wartości w obie strony i odpala istniejące przeliczenia/rysowanie.
 */
(function () {
  // mapowanie: id suwaka -> id spana z wyświetlaną wartością
  function spanIdFor(rangeId) {
    const m = rangeId.match(/(\D+)(\d+)$/); // np. "widthRange1" -> ["widthRange1","widthRange","1"]
    if (!m) return null;
    const base = m[1], id = m[2];
    if (base === 'widthRange') return `widthValue${id}`;
    if (base === 'lengthRange') return `lengthValue${id}`;
    if (base === 'heightRange') return `heightValue${id}`;
    if (base === 'heightPeakRange') return `heightPeakValue${id}`;
    return null;
  }

  function clampToStep(val, min, max, step) {
    const v = Math.min(Math.max(val, min), max);
    const s = step > 0 ? step : 1;
    // zaokrąglanie do kroku (np. 0.1)
    const r = Math.round((v - min) / s) * s + min;
    // uniknij "1.999999" – tnij do 3 miejsc po przecinku
    return parseFloat(r.toFixed(3));
  }

  function wirePair(range, number) {
    // z suwaka -> number (na żywo)
    const syncFromRange = () => {
      number.value = range.value;
      // odśwież wyświetlaną wartość przy suwaku (span)
      const sid = spanIdFor(range.id);
      const span = sid ? document.getElementById(sid) : null;
      if (span) {
        const v = parseFloat(range.value);
        span.textContent = Number.isFinite(v) ? v.toFixed(1) : range.value;
      }
    };

    // z number -> suwak (po zmianie / wpisaniu)
    const syncFromNumber = () => {
      const min  = parseFloat(range.min || '0');
      const max  = parseFloat(range.max || '0');
      const step = parseFloat(range.step || '1');
      let v = parseFloat(number.value.replace(',', '.'));
      if (!Number.isFinite(v)) v = min;

      v = clampToStep(v, min, max, step);
      range.value = v;

      // Bardzo ważne: wyślij event "input", żeby uruchomić Twoje istniejące nasłuchy,
      // które pilnują zależności (np. kalenica ≥ okap + 0.2), rysują SVG i liczą cenę.
      range.dispatchEvent(new Event('input', { bubbles: true }));

      // dopisz również do spana
      syncFromRange();
    };

    // podpięcia
    range.addEventListener('input', syncFromRange);
    number.addEventListener('change', syncFromNumber);
    number.addEventListener('blur', syncFromNumber);

    // inicjalny sync
    syncFromRange();
  }

  function enhanceRanges() {
    document.querySelectorAll('.build-container input[type="range"]').forEach(range => {
      // jeżeli już wstawiliśmy pole number obok, nie rób drugi raz
      if (range.nextElementSibling && range.nextElementSibling.dataset?.rangeNumberFor === range.id) return;

      // utwórz pole number z tymi samymi ograniczeniami
      const number = document.createElement('input');
      number.type = 'number';
      number.min = range.min;
      number.max = range.max;
      number.step = range.step || '1';
      number.value = range.value;
      number.dataset.rangeNumberFor = range.id;

      // lekkie style (możesz podmienić na własne klasy Bootstrap)
      number.className = 'form-control d-inline-block ms-2';
      number.style.width = '100px';
      number.inputMode = 'decimal';

      // wstaw zaraz po suwaku i zintegruj
      range.insertAdjacentElement('afterend', number);
      wirePair(range, number);
    });
  }

  // odpal po załadowaniu DOM i po Twojej inicjalizacji
  document.addEventListener('DOMContentLoaded', () => {
    // poczekaj klatkę, żeby wszystkie Twoje listenery już działały
    requestAnimationFrame(enhanceRanges);
  });

  // jeśli w trakcie działania przełączasz kontenery (burger menu),
  // suwaki pozostają te same – nic nie trzeba robić. Gdybyś kiedyś
  // dodawał suwaki dynamicznie, po dodaniu wywołaj enhanceRanges().
})();
</script>









<!-- SAVE PROJECT MODAL -->
<div class="modal fade" id="saveProjectModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Twój projekt – zapis i kontakt</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Zamknij"></button>
      </div>

      <div class="modal-body">
        <!-- 1) PDF -->
        <div class="mb-3">
          <button id="downloadPdfBtn" class="btn btn-primary w-100">
            <i class="fa-solid fa-file-pdf me-2"></i>Pobierz PDF z projektem
          </button>
          <div class="form-text">
            Ten sam PDF dołączymy automatycznie do maila wysyłanego z formularza poniżej.
          </div>
          <div id="pdfPreview" class="border rounded p-2 mt-2 text-center small" style="min-height:120px;">
            Podgląd pojawi się po wygenerowaniu…
          </div>
        </div>

        <hr class="my-4" />

        <!-- 2) Kontakt telefoniczny -->
        <div class="d-flex align-items-center gap-3 mb-3">
          <img src="asystent.webp" width="64" height="64" class="rounded-circle object-fit-cover" alt="Asystent Zabudo">
          <div>
            <div class="fw-semibold">Twój asystent: Adam</div>
            <a href="tel:+48503702467" class="btn asystent-numer">
              <i class="fa-solid fa-phone me-2"></i>+48 503 702 467
            </a>
          </div>
        </div>

        <hr class="my-4" />

        <!-- 3) Formularz (klon) -->
        <div id="modalFormSlot"></div>
      </div>
    </div>
  </div>
</div>

<style>
  /* rozmiary modala */
  #saveProjectModal .modal-body{ max-height:80vh; overflow:auto; }
  @media (min-width: 992px){
    #saveProjectModal .modal-dialog{ max-width:40vw; }
  }
  @media (max-width: 991.98px){
    #saveProjectModal .modal-dialog{ max-width:95vw; margin:1rem auto; }
  }
</style>



</body>
</html>

























































